<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rubik's Cube Simulator</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
      }

      .main-container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .canvas-with-rotation {
        position: relative;
        display: flex;
        justify-content: center;
      }

      .canvas-container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #canvas {
        border: 1px solid #ccc;
        background-color: #000;
        cursor: grab;
      }

      #canvas:active {
        cursor: grabbing;
      }

      .controls {
        margin-top: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #45a049;
      }

      .face-buttons {
        display: flex;
        gap: 5px;
      }

      .face-buttons button {
        background-color: #2196f3;
      }

      .face-buttons button:hover {
        background-color: #0b7dda;
      }

      .reorientation-buttons button {
        background-color: #9c27b0;
      }

      .reorientation-buttons button:hover {
        background-color: #7b1fa2;
      }

      .reorientation-buttons {
        display: flex;
        gap: 5px;
      }

      .slice-buttons {
        display: flex;
        gap: 5px;
      }

      .slice-buttons button {
        background-color: #ff5722;
        font-size: 14px;
        min-width: 50px;
      }

      .slice-buttons button:hover {
        background-color: #e64a19;
      }

      .rotation-controls {
        position: absolute;
        right: -90px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }

      .rotation-button {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: #ff9800;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s;
        user-select: none;
      }

      .rotation-button:hover {
        background-color: #e68900;
      }

      .rotation-button:active {
        background-color: #cc7a00;
      }

      .rotation-button svg {
        width: 30px;
        height: 30px;
        fill: white;
      }

      #reset-orientation-btn {
        background-color: #9c27b0;
      }

      #reset-orientation-btn:hover {
        background-color: #7b1fa2;
      }

      #reset-orientation-btn:active {
        background-color: #6a1b9a;
      }

      .sequence-input {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
      }

      #move-sequence {
        padding: 8px 12px;
        font-size: 14px;
        border: 2px solid #ccc;
        border-radius: 5px;
        width: 400px;
        font-family: 'Courier New', monospace;
        background-color: white;
        transition: border-color 0.3s;
      }

      #move-sequence:focus {
        outline: none;
        border-color: #4caf50;
      }

      .sequence-input button {
        padding: 8px 16px;
        font-size: 14px;
      }

      .error-dialog {
        border: none;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        padding: 20px;
        max-width: 400px;
        text-align: center;
      }

      .error-dialog::backdrop {
        background-color: rgba(0, 0, 0, 0.5);
      }

      .error-dialog h3 {
        color: #e53e3e;
        margin-top: 0;
      }

      .error-dialog button {
        background-color: #e53e3e;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 10px;
      }

      .error-dialog button:hover {
        background-color: #c53030;
      }
    </style>
  </head>
  <body>
    <h1>Rubik's Cube Simulator</h1>
    
    <div class="main-container">
      <div class="canvas-container">
        <div class="canvas-with-rotation">
          <canvas id="canvas" width="600" height="600"></canvas>
          
          <div class="rotation-controls">
            <button class="rotation-button" id="counterclockwise-btn" title="Hold to rotate cube counterclockwise">
              <svg viewBox="0 0 24 24">
                <path d="M12 6V9l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6z" fill="white"/>
              </svg>
            </button>
            <button class="rotation-button" id="clockwise-btn" title="Hold to rotate cube clockwise">
              <svg viewBox="0 0 24 24">
                <path d="M12 6V9l-4-4 4-4v3c4.42 0 8 3.58 8 8 0 1.57-.46 3.03-1.24 4.26L17.3 14.8c.45-.83.7-1.79.7-2.8 0-3.31-2.69-6-6-6z" fill="white"/>
              </svg>
            </button>
            <button class="rotation-button" id="reset-orientation-btn" title="Reset cube orientation to default view">
              <svg viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z" fill="white"/>
              </svg>
            </button>
          </div>
        </div>

        <div class="controls">
          <div class="face-buttons">
            <button onclick="renderer.animateVisualMove('U')">U</button>
            <button onclick="renderer.animateVisualMove('U\'')">U'</button>
            <button onclick="renderer.animateVisualMove('D')">D</button>
            <button onclick="renderer.animateVisualMove('D\'')">D'</button>
            <button onclick="renderer.animateVisualMove('R')">R</button>
            <button onclick="renderer.animateVisualMove('R\'')">R'</button>
            <button onclick="renderer.animateVisualMove('L')">L</button>
            <button onclick="renderer.animateVisualMove('L\'')">L'</button>
            <button onclick="renderer.animateVisualMove('F')">F</button>
            <button onclick="renderer.animateVisualMove('F\'')">F'</button>
            <button onclick="renderer.animateVisualMove('B')">B</button>
            <button onclick="renderer.animateVisualMove('B\'')">B'</button>
          </div>
        </div>

        <div class="controls">
          <div class="reorientation-buttons">
            <button onclick="renderer.animateVisualMove('x')">x</button>
            <button onclick="renderer.animateVisualMove('x\'')">x'</button>
            <button onclick="renderer.animateVisualMove('y')">y</button>
            <button onclick="renderer.animateVisualMove('y\'')">y'</button>
            <button onclick="renderer.animateVisualMove('z')">z</button>
            <button onclick="renderer.animateVisualMove('z\'')">z'</button>
          </div>
        </div>

        <div class="controls">
          <div class="slice-buttons">
            <button onclick="renderer.animateVisualMove('M')">M</button>
            <button onclick="renderer.animateVisualMove('M\'')">M'</button>
            <button onclick="renderer.animateVisualMove('E')">E</button>
            <button onclick="renderer.animateVisualMove('E\'')">E'</button>
            <button onclick="renderer.animateVisualMove('S')">S</button>
            <button onclick="renderer.animateVisualMove('S\'')">S'</button>
          </div>
        </div>

        <div class="controls">
          <div class="sequence-input">
            <input type="text" id="move-sequence" placeholder="Enter moves: R U R' U' R' F R2 U' R' U' R U R' F'" />
            <button id="execute-move-sequence">Execute</button>
          </div>
        </div>

        <div class="controls">
          <button id="scramble">Scramble</button>
          <button id="reset">Reset</button>
        </div>
      </div>
    </div>

    <dialog id="error-dialog" class="error-dialog">
      <h3>Invalid Move Sequence</h3>
      <p id="error-message"></p>
      <button onclick="hideErrorModal()">OK</button>
    </dialog>

    <script type="module">
      import { RubiksCube } from './cube.js';
      import { CubeRenderer } from './renderer.js';

      window.cube = new RubiksCube();
      window.renderer = new CubeRenderer(document.getElementById('canvas'), cube);

      // Scramble function
      // This tries to be clever for the rendering. If doing statistics, be dumb instead.
      async function scrambleCube() {
        const moves = ['U', "U'", 'D', "D'", 'R', "R'", 'L', "L'", 'F', "F'", 'B', "B'"];
        const scrambleLength = 30 + Math.floor(Math.random() * 11);

        // Helper function to get the base face (without prime)
        const getBaseFace = (move) => move.replace("'", "");

        // Helper function to get the inverse of a move
        const getInverse = (move) => move.includes("'") ? move.replace("'", "") : move + "'";

        // Helper function to check if two faces are opposite
        const areOppositeFaces = (face1, face2) => {
          const opposites = { 'U': 'D', 'D': 'U', 'R': 'L', 'L': 'R', 'F': 'B', 'B': 'F' };
          return opposites[face1] === face2;
        };

        const scramble = [];

        for (let i = 0; i < scrambleLength; i++) {
          let validMoves = [...moves];

          if (scramble.length > 0) {
            const lastMove = scramble[scramble.length - 1];
            const lastBaseFace = getBaseFace(lastMove);

            // Remove inverse of last move
            const lastInverse = getInverse(lastMove);
            validMoves = validMoves.filter(move => move !== lastInverse);

            // If last two moves were on same face, prevent third consecutive same face move
            if (scramble.length > 1) {
              const secondLastMove = scramble[scramble.length - 2];
              const secondLastBaseFace = getBaseFace(secondLastMove);

              if (lastBaseFace === secondLastBaseFace) {
                // Already have 2 consecutive moves on same face, don't allow a third
                validMoves = validMoves.filter(move => getBaseFace(move) !== lastBaseFace);
              }

              // Check for opposite face sandwich patterns
              // Case 1: U D U' - second-to-last and last are opposite faces
              if (areOppositeFaces(secondLastBaseFace, lastBaseFace)) {
                const secondLastInverse = getInverse(secondLastMove);
                validMoves = validMoves.filter(move => move !== secondLastInverse);
              }

              // Case 2: U D D U' - need to look back one more step
              if (scramble.length > 2) {
                const thirdLastMove = scramble[scramble.length - 3];
                const thirdLastBaseFace = getBaseFace(thirdLastMove);

                // If last two moves are same face and opposite to third-to-last, avoid third-to-last inverse
                if (lastBaseFace === secondLastBaseFace && areOppositeFaces(thirdLastBaseFace, lastBaseFace)) {
                  const thirdLastInverse = getInverse(thirdLastMove);
                  validMoves = validMoves.filter(move => move !== thirdLastInverse);
                }
              }
            }
          }

          // If we've filtered out all moves (shouldn't happen with good logic), fall back to rejection
          if (validMoves.length === 0) {
            validMoves = [...moves];
          }

          const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
          scramble.push(randomMove);
          await renderer.animateMove(randomMove);
        }
      }

      function resetCube() {
        cube.reset();
        renderer.render(); // Will show checkmark since cube is now solved
      }

      // Reset orientation function
      function resetOrientation() {
        renderer.orientation = [0.1, 0.8, 0.1, 0.6];
        renderer.render();
      }

      // Parse move sequence string into individual moves
      function parseMoveSequence(sequence) {
        // Remove all whitespace
        const cleanSequence = sequence.replace(/\s/g, '');
        const moves = [];
        const invalidChars = [];

        let i = 0;
        while (i < cleanSequence.length) {
          const char = cleanSequence[i];
          
          if (/[UDRLFBxyzMES]/.test(char)) {
            let move = char;
            
            // Check for prime or 2
            if (i + 1 < cleanSequence.length) {
              if (cleanSequence[i + 1] === "'") {
                move += "'";
                i++;
              } else if (cleanSequence[i + 1] === "2") {
                moves.push(move, move); // Add twice for double move
                i += 2;
                continue;
              }
            }
            
            moves.push(move);
          } else if (!invalidChars.includes(char)) {
            invalidChars.push(char);
          }
          i++;
        }

        return { moves, invalidChars };
      }

      // Show error modal
      function showErrorModal(message) {
        const dialog = document.getElementById('error-dialog');
        const messageElement = document.getElementById('error-message');
        messageElement.innerHTML = message;
        dialog.showModal();
      }

      // Hide error modal
      function hideErrorModal() {
        const dialog = document.getElementById('error-dialog');
        dialog.close();
      }

      // Execute a sequence of moves
      async function executeMoveSequence() {
        const input = document.getElementById('move-sequence');
        const sequence = input.value.trim();
        
        if (!sequence) return;

        const result = parseMoveSequence(sequence);
        
        // Check for invalid characters
        if (result.invalidChars.length > 0) {
          const invalidStr = result.invalidChars.map(c => `'${c}'`).join(', ');
          showErrorModal(`Unrecognized characters: ${invalidStr}<br><br>Valid characters are: U, D, R, L, F, B, x, y, z, ', 2`);
          return;
        }

        // Execute each move in sequence using visual moves
        for (const move of result.moves) {
          await renderer.animateVisualMove(move);
        }
      }

      let isRotating = false;
      let rotationDirection = 0; // 1 for clockwise, -1 for counterclockwise
      let rotationAnimationId = null;

      // Z-axis rotation functions
      function rotateZ(direction) {
        const rotationSpeed = 0.02; // Adjust speed as needed
        const zRotation = Math3D.quat_fromAxisAngle(Math3D.quat_create(), [0, 0, 1], direction * rotationSpeed);
        Math3D.quat_multiply(renderer.orientation, zRotation, renderer.orientation);
        Math3D.quat_normalize(renderer.orientation, renderer.orientation);
        renderer.render();
      }

      function startRotation(direction) {
        if (isRotating) return;
        isRotating = true;
        rotationDirection = direction;
        
        function animate() {
          if (isRotating) {
            rotateZ(rotationDirection);
            rotationAnimationId = requestAnimationFrame(animate);
          }
        }
        animate();
      }

      function stopRotation() {
        isRotating = false;
        if (rotationAnimationId) {
          cancelAnimationFrame(rotationAnimationId);
          rotationAnimationId = null;
        }
      }


      // Initial render
      renderer.render();

      // Setup rotation button event handlers
      const clockwiseBtn = document.getElementById('clockwise-btn');
      const counterclockwiseBtn = document.getElementById('counterclockwise-btn');

      // Clockwise button events
      clockwiseBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startRotation(-1);
      });

      clockwiseBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopRotation();
      });

      clockwiseBtn.addEventListener('mouseleave', (e) => {
        stopRotation();
      });

      // Counterclockwise button events  
      counterclockwiseBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startRotation(1);
      });

      counterclockwiseBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopRotation();
      });

      counterclockwiseBtn.addEventListener('mouseleave', (e) => {
        stopRotation();
      });

      document.addEventListener('mouseup', () => {
        stopRotation();
      });

      document.getElementById('reset-orientation-btn').addEventListener('click', resetOrientation);

      document.getElementById('scramble').addEventListener('click', scrambleCube);

      document.getElementById('reset').addEventListener('click', resetCube);

      document.getElementById('move-sequence').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          executeMoveSequence();
        }
      });

      document.getElementById('execute-move-sequence').addEventListener('click', executeMoveSequence);
    </script>
  </body>
</html>
