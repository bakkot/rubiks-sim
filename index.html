<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rubik's Cube Simulator</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
      }

      #canvas {
        border: 1px solid #ccc;
        background-color: #000;
        cursor: grab;
      }

      #canvas:active {
        cursor: grabbing;
      }

      .controls {
        margin-top: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #45a049;
      }

      .face-buttons {
        display: flex;
        gap: 5px;
      }

      .face-buttons button {
        background-color: #2196f3;
      }

      .face-buttons button:hover {
        background-color: #0b7dda;
      }
    </style>
  </head>
  <body>
    <h1>Rubik's Cube Simulator</h1>
    <canvas id="canvas" width="600" height="600"></canvas>

    <div class="controls">
      <div class="face-buttons">
        <button onclick="renderer.animateVisualMove('U')">U</button>
        <button onclick="renderer.animateVisualMove('U\'')">U'</button>
        <button onclick="renderer.animateVisualMove('D')">D</button>
        <button onclick="renderer.animateVisualMove('D\'')">D'</button>
        <button onclick="renderer.animateVisualMove('R')">R</button>
        <button onclick="renderer.animateVisualMove('R\'')">R'</button>
        <button onclick="renderer.animateVisualMove('L')">L</button>
        <button onclick="renderer.animateVisualMove('L\'')">L'</button>
        <button onclick="renderer.animateVisualMove('F')">F</button>
        <button onclick="renderer.animateVisualMove('F\'')">F'</button>
        <button onclick="renderer.animateVisualMove('B')">B</button>
        <button onclick="renderer.animateVisualMove('B\'')">B'</button>
      </div>
    </div>

    <div class="controls">
      <button onclick="scrambleCube()">Scramble</button>
      <button onclick="resetCube()">Reset</button>
      <button onclick="resetOrientation()">Reset Orientation</button>
    </div>

    <script>
      class RubiksCube {
        constructor() {
          this.reset();
        }

        reset() {
          this.corners = [
            { id: 0, orientation: 0, colors: ['white', 'red', 'green'] }, // URF
            { id: 1, orientation: 0, colors: ['white', 'green', 'orange'] }, // UFL
            { id: 2, orientation: 0, colors: ['white', 'orange', 'blue'] }, // ULB
            { id: 3, orientation: 0, colors: ['white', 'blue', 'red'] }, // UBR
            { id: 4, orientation: 0, colors: ['yellow', 'green', 'red'] }, // DFR
            { id: 5, orientation: 0, colors: ['yellow', 'orange', 'green'] }, // DLF
            { id: 6, orientation: 0, colors: ['yellow', 'blue', 'orange'] }, // DBL
            { id: 7, orientation: 0, colors: ['yellow', 'red', 'blue'] }, // DRB
          ];

          this.edges = [
            { id: 0, orientation: 0, colors: ['white', 'red'] }, // UR
            { id: 1, orientation: 0, colors: ['white', 'green'] }, // UF
            { id: 2, orientation: 0, colors: ['white', 'orange'] }, // UL
            { id: 3, orientation: 0, colors: ['white', 'blue'] }, // UB
            { id: 4, orientation: 0, colors: ['yellow', 'red'] }, // DR
            { id: 5, orientation: 0, colors: ['yellow', 'green'] }, // DF
            { id: 6, orientation: 0, colors: ['yellow', 'orange'] }, // DL
            { id: 7, orientation: 0, colors: ['yellow', 'blue'] }, // DB
            { id: 8, orientation: 0, colors: ['green', 'red'] }, // FR
            { id: 9, orientation: 0, colors: ['green', 'orange'] }, // FL
            { id: 10, orientation: 0, colors: ['blue', 'orange'] }, // BL
            { id: 11, orientation: 0, colors: ['blue', 'red'] }, // BR
          ];
        }

        // Apply a move
        move(notation) {
          const moveMap = {
            U: () => this.U(),
            "U'": () => this.Uprime(),
            U2: () => {
              this.U();
              this.U();
            },
            D: () => this.D(),
            "D'": () => this.Dprime(),
            D2: () => {
              this.D();
              this.D();
            },
            R: () => this.R(),
            "R'": () => this.Rprime(),
            R2: () => {
              this.R();
              this.R();
            },
            L: () => this.L(),
            "L'": () => this.Lprime(),
            L2: () => {
              this.L();
              this.L();
            },
            F: () => this.F(),
            "F'": () => this.Fprime(),
            F2: () => {
              this.F();
              this.F();
            },
            B: () => this.B(),
            "B'": () => this.Bprime(),
            B2: () => {
              this.B();
              this.B();
            },
          };

          if (moveMap[notation]) {
            moveMap[notation]();
          }
        }

        cyclePieces(pieces, cycle, oriChange = 0) {
          const isCorner = pieces === this.corners;
          const first = pieces[cycle[0]];
          for (let i = cycle.length - 1; i >= 0; --i) {
            const piece = i === 0 ? first : pieces[cycle[i]];
            const newPos = cycle[(i + 1) % cycle.length];
            const dist = newPos - cycle[i];
            const sign = dist % 2 === 0 ? 1 : -1;
            piece.orientation = ((isCorner ? 3 : 2) + piece.orientation + sign * oriChange) % (isCorner ? 3 : 2);
            pieces[newPos] = piece;
          }
        }

        // Face moves
        U() {
          this.cyclePieces(this.corners, [0, 1, 2, 3], 0);
          this.cyclePieces(this.edges, [0, 1, 2, 3], 0);
        }

        Uprime() {
          this.cyclePieces(this.corners, [3, 2, 1, 0], 0);
          this.cyclePieces(this.edges, [3, 2, 1, 0], 0);
        }

        D() {
          this.cyclePieces(this.corners, [4, 7, 6, 5], 0);
          this.cyclePieces(this.edges, [4, 7, 6, 5], 0);
        }

        Dprime() {
          this.cyclePieces(this.corners, [5, 6, 7, 4], 0);
          this.cyclePieces(this.edges, [5, 6, 7, 4], 0);
        }

        R() {
          this.cyclePieces(this.corners, [0, 3, 7, 4], 1);
          this.cyclePieces(this.edges, [0, 11, 4, 8], 0);
        }

        Rprime() {
          this.cyclePieces(this.corners, [4, 7, 3, 0], 2);
          this.cyclePieces(this.edges, [8, 4, 11, 0], 0);
        }

        L() {
          this.cyclePieces(this.corners, [2, 1, 5, 6], 1);
          this.cyclePieces(this.edges, [2, 9, 6, 10], 0);
        }

        Lprime() {
          this.cyclePieces(this.corners, [6, 5, 1, 2], 2);
          this.cyclePieces(this.edges, [10, 6, 9, 2], 0);
        }

        F() {
          this.cyclePieces(this.corners, [1, 0, 4, 5], 1);
          this.cyclePieces(this.edges, [1, 8, 5, 9], 1);
        }

        Fprime() {
          this.cyclePieces(this.corners, [5, 4, 0, 1], 2);
          this.cyclePieces(this.edges, [9, 5, 8, 1], 1);
        }

        B() {
          this.cyclePieces(this.corners, [3, 2, 6, 7], 1);
          this.cyclePieces(this.edges, [3, 10, 7, 11], 1);
        }

        Bprime() {
          this.cyclePieces(this.corners, [7, 6, 2, 3], 2);
          this.cyclePieces(this.edges, [11, 7, 10, 3], 1);
        }
      }

      /**
       * A collection of self-contained math utilities for 3D rotation.
       * Quaternions are represented as [x, y, z, w].
       * 4x4 Matrices are represented as a 16-element Float32Array in column-major order.
       */
      const Math3D = {
        // --- Quaternion Functions ---

        /** Creates an identity quaternion [0, 0, 0, 1] */
        quat_create: function () {
          return [0, 0, 0, 1];
        },

        /**
         * Creates a quaternion from a rotation around an axis.
         * @param {Float32Array} out The receiving quaternion.
         * @param {Array<number>} axis The axis of rotation.
         * @param {number} rad The angle of rotation in radians.
         */
        quat_fromAxisAngle: function (out, axis, rad) {
          const halfAngle = rad / 2;
          const s = Math.sin(halfAngle);
          out[0] = axis[0] * s;
          out[1] = axis[1] * s;
          out[2] = axis[2] * s;
          out[3] = Math.cos(halfAngle);
          return out;
        },

        /**
         * Multiplies two quaternions. Order matters: a * b applies rotation b then a.
         * @param {Float32Array} out The receiving quaternion.
         * @param {Float32Array} a The first operand.
         * @param {Float32Array} b The second operand.
         */
        quat_multiply: function (out, a, b) {
          const ax = a[0],
            ay = a[1],
            az = a[2],
            aw = a[3];
          const bx = b[0],
            by = b[1],
            bz = b[2],
            bw = b[3];
          out[0] = ax * bw + aw * bx + ay * bz - az * by;
          out[1] = ay * bw + aw * by + az * bx - ax * bz;
          out[2] = az * bw + aw * bz + ax * by - ay * bx;
          out[3] = aw * bw - ax * bx - ay * by - az * bz;
          return out;
        },

        /**
         * Normalizes a quaternion.
         * @param {Float32Array} out The receiving quaternion.
         * @param {Float32Array} q The quaternion to normalize.
         */
        quat_normalize: function (out, q) {
          let len = q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3];
          if (len > 0) {
            len = 1 / Math.sqrt(len);
          }
          out[0] = q[0] * len;
          out[1] = q[1] * len;
          out[2] = q[2] * len;
          out[3] = q[3] * len;
          return out;
        },

        // --- Matrix Functions ---

        /**
         * Creates a 4x4 rotation matrix from a quaternion.
         * @param {Float32Array} out The receiving 16-element matrix.
         * @param {Float32Array} q The quaternion.
         */
        mat4_fromQuat: function (out, q) {
          const x = q[0],
            y = q[1],
            z = q[2],
            w = q[3];
          const x2 = x + x,
            y2 = y + y,
            z2 = z + z;
          const xx = x * x2,
            xy = x * y2,
            xz = x * z2;
          const yy = y * y2,
            yz = y * z2,
            zz = z * z2;
          const wx = w * x2,
            wy = w * y2,
            wz = w * z2;

          out[0] = 1 - (yy + zz);
          out[1] = xy + wz;
          out[2] = xz - wy;
          out[3] = 0;

          out[4] = xy - wz;
          out[5] = 1 - (xx + zz);
          out[6] = yz + wx;
          out[7] = 0;

          out[8] = xz + wy;
          out[9] = yz - wx;
          out[10] = 1 - (xx + yy);
          out[11] = 0;

          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
          out[15] = 1;
          return out;
        },

        /**
         * Transforms a 3D vector by a quaternion.
         * @param {Array<number>} out The receiving 3-element vector.
         * @param {Array<number>} v The 3-element vector to transform.
         * @param {Float32Array} q The quaternion to rotate by.
         */
        vec3_transformQuat: function (out, v, q) {
          // This is a standard, optimized method for vector-quaternion rotation.
          const qx = q[0],
            qy = q[1],
            qz = q[2],
            qw = q[3];
          const vx = v[0],
            vy = v[1],
            vz = v[2];

          // Calculate uv = 2 * cross(q.xyz, v)
          const uvx = 2 * (qy * vz - qz * vy);
          const uvy = 2 * (qz * vx - qx * vz);
          const uvz = 2 * (qx * vy - qy * vx);

          // out = v + q.w * uv + cross(q.xyz, uv)
          out[0] = vx + qw * uvx + (qy * uvz - qz * uvy);
          out[1] = vy + qw * uvy + (qz * uvx - qx * uvz);
          out[2] = vz + qw * uvz + (qx * uvy - qy * uvx);
          return out;
        },
      };

      // 3D Renderer
      class CubeRenderer {
        constructor(canvas, cube) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.cube = cube;
          this.orientation = [0.1, 0.8, 0.1, 0.6];
          this.scale = 100;

          this.setupInteraction();

          this.animating = false;
          this.animationQueue = [];
          this.animationProgress = 0;
          this.animationDuration = 300; // milliseconds
          this.currentAnimation = null;
        }

        setupInteraction() {
          let isDragging = false;
          let lastX, lastY;

          this.canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
          });

          const rotationSpeed = 0.008;

          window.addEventListener('mousemove', e => {
            if (!isDragging) return;

            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;

            // Create a temporary quaternion to represent the new rotation
            const deltaQuat = Math3D.quat_create();

            // Create a rotation from the horizontal drag (around the Y-axis)
            const rotY = Math3D.quat_fromAxisAngle(Math3D.quat_create(), [0, 1, 0], -deltaX * rotationSpeed);

            // Create a rotation from the vertical drag (around the X-axis)
            const rotX = Math3D.quat_fromAxisAngle(Math3D.quat_create(), [1, 0, 0], deltaY * rotationSpeed);

            // Combine the two new rotations (Y rotation then X rotation)
            Math3D.quat_multiply(deltaQuat, rotY, rotX);

            // Combine this new delta rotation with the cube's current orientation.
            // The order is crucial: new_orientation = delta_rotation * current_orientation
            // This applies the drag relative to the screen/view axes.
            Math3D.quat_multiply(this.orientation, deltaQuat, this.orientation);

            // Normalize the result to prevent floating point errors from accumulating
            Math3D.quat_normalize(this.orientation, this.orientation);

            lastX = e.clientX;
            lastY = e.clientY;

            this.render();
          });

          window.addEventListener('mouseup', () => {
            isDragging = false;
          });
        }

        // Map visual face positions to logical faces based on current rotation
        getVisualToLogicalMapping() {
          // Define the standard face normals for each logical face
          const faceNormals = {
            U: [0, -1, 0], // Up face points down in our coordinate system
            D: [0, 1, 0], // Down face points up
            R: [1, 0, 0], // Right face points right
            L: [-1, 0, 0], // Left face points left
            F: [0, 0, -1], // Front face points toward viewer
            B: [0, 0, 1], // Back face points away from viewer
          };

          // Define visual directions we want to check against
          const visualDirections = {
            visualUp: [0, -1, 0], // Visual up is negative Y
            visualDown: [0, 1, 0], // Visual down is positive Y
            visualRight: [1, 0, 0], // Visual right is positive X
            visualLeft: [-1, 0, 0], // Visual left is negative X
            visualFront: [0, 0, -1], // Visual front is negative Z
            visualBack: [0, 0, 1], // Visual back is positive Z
          };

          const mapping = {};

          // For each visual direction, find which logical face is closest to it
          Object.entries(visualDirections).forEach(([visualPos, visualDir]) => {
            let bestMatch = null;
            let bestDot = -2; // Start with impossible dot product value

            // Check each logical face
            Object.entries(faceNormals).forEach(([logicalFace, normal]) => {
              // Transform the logical face normal by the current orientation
              const transformedNormal = [0, 0, 0];
              Math3D.vec3_transformQuat(transformedNormal, normal, this.orientation);

              // Calculate dot product to find how aligned they are
              const dot =
                transformedNormal[0] * visualDir[0] +
                transformedNormal[1] * visualDir[1] +
                transformedNormal[2] * visualDir[2];

              // Keep track of the best match
              if (dot > bestDot) {
                bestDot = dot;
                bestMatch = logicalFace;
              }
            });

            mapping[visualPos] = bestMatch;
          });

          return mapping;
        }

        // Convert visual move notation to logical move notation
        visualMoveToLogical(visualMove) {
          const mapping = this.getVisualToLogicalMapping();
          const isPrime = visualMove.includes("'");
          const baseFace = visualMove.charAt(0);

          let logicalFace;
          switch (baseFace) {
            case 'U':
              logicalFace = mapping.visualUp;
              break;
            case 'D':
              logicalFace = mapping.visualDown;
              break;
            case 'R':
              logicalFace = mapping.visualRight;
              break;
            case 'L':
              logicalFace = mapping.visualLeft;
              break;
            case 'F':
              logicalFace = mapping.visualFront;
              break;
            case 'B':
              logicalFace = mapping.visualBack;
              break;
            default:
              throw new Error(`not a move: ${baseFace}`);
          }

          return logicalFace + (isPrime ? "'" : '');
        }

        animateMove(move) {
          return new Promise(resolve => {
            this.animationQueue.push({ move, resolve });
            if (!this.animating) {
              this.processAnimationQueue();
            }
          });
        }

        // Animate a move based on visual orientation
        animateVisualMove(visualMove) {
          const logicalMove = this.visualMoveToLogical(visualMove);
          return this.animateMove(logicalMove);
        }

        processAnimationQueue() {
          if (this.animationQueue.length === 0) {
            this.animating = false;
            return;
          }

          this.animating = true;
          const { move, resolve } = this.animationQueue.shift();
          this.currentAnimation = { move, resolve, startTime: Date.now() };

          const animate = () => {
            const elapsed = Date.now() - this.currentAnimation.startTime;
            this.animationProgress = Math.min(elapsed / this.animationDuration, 1);

            this.render();

            if (this.animationProgress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Apply the actual move to the cube state
              this.cube.move(this.currentAnimation.move);
              this.animationProgress = 0;
              this.currentAnimation.resolve();
              this.currentAnimation = null;
              this.render();
              this.processAnimationQueue();
            }
          };

          animate();
        }

        getRotationMatrix(axis, angle) {
          const c = Math.cos(angle);
          const s = Math.sin(angle);

          if (axis === 'y') {
            return {
              x: (x, y, z) => x * c - z * s,
              y: (x, y, z) => y,
              z: (x, y, z) => x * s + z * c,
            };
          } else if (axis === 'x') {
            return {
              x: (x, y, z) => x,
              y: (x, y, z) => y * c - z * s,
              z: (x, y, z) => y * s + z * c,
            };
          } else if (axis === 'z') {
            return {
              x: (x, y, z) => x * c - y * s,
              y: (x, y, z) => x * s + y * c,
              z: (x, y, z) => z,
            };
          }
        }

        isPieceAffectedByMove(pieceType, piecePos, move) {
          const face = move.charAt(0);

          if (face === 'U') return piecePos.y < -0.5;
          if (face === 'D') return piecePos.y > 0.5;
          if (face === 'R') return piecePos.x > 0.5;
          if (face === 'L') return piecePos.x < -0.5;
          if (face === 'F') return piecePos.z < -0.5;
          if (face === 'B') return piecePos.z > 0.5;

          return false;
        }

        project3D(x, y, z, applyAnimation) {
          // Apply animation rotation if active
          if (applyAnimation && this.currentAnimation) {
            const move = this.currentAnimation.move;
            const face = move.charAt(0);
            const isPrime = move.includes("'");

            let axis, angle;
            if (face === 'U' || face === 'D') {
              axis = 'y';
              angle = (((face === 'U' ? -1 : 1) * (isPrime ? -1 : 1) * Math.PI) / 2) * this.animationProgress;
            } else if (face === 'R' || face === 'L') {
              axis = 'x';
              angle = (((face === 'R' ? 1 : -1) * (isPrime ? 1 : -1) * Math.PI) / 2) * this.animationProgress;
            } else if (face === 'F' || face === 'B') {
              axis = 'z';
              angle = (((face === 'B' ? -1 : 1) * (isPrime ? -1 : 1) * Math.PI) / 2) * this.animationProgress;
            }

            const rotation = this.getRotationMatrix(axis, angle);
            const newX = rotation.x(x, y, z);
            const newY = rotation.y(x, y, z);
            const newZ = rotation.z(x, y, z);
            x = newX;
            y = newY;
            z = newZ;
          }

          const rotatedPoint = [0, 0, 0];
          Math3D.vec3_transformQuat(rotatedPoint, [x, y, z], this.orientation);

          const x1 = rotatedPoint[0];
          const y1 = rotatedPoint[1];
          const z2 = rotatedPoint[2];

          // Project to 2D
          const perspective = 1000 / (1000 + z2);
          const projX = x1 * this.scale * perspective + this.canvas.width / 2;
          const projY = y1 * this.scale * perspective + this.canvas.height / 2;

          return { x: projX, y: projY, z: z2 };
        }

        drawSticker(corners, color) {
          this.ctx.beginPath();
          this.ctx.moveTo(corners[0].x, corners[0].y);
          for (let i = 1; i < corners.length; i++) {
            this.ctx.lineTo(corners[i].x, corners[i].y);
          }
          this.ctx.closePath();

          const colorMap = {
            white: '#FFFFFF',
            yellow: '#FFD500',
            red: '#B71234',
            orange: '#FF5800',
            green: '#009E60',
            blue: '#0051BA',
          };

          this.ctx.fillStyle = colorMap[color] || color;
          this.ctx.fill();
          this.ctx.strokeStyle = '#000';
          this.ctx.lineWidth = 2;
          this.ctx.stroke();
        }

        render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          const faces = [];

          // Define piece positions and orientations
          const cornerPositions = [
            { x: 1, y: -1, z: -1 }, // URF
            { x: -1, y: -1, z: -1 }, // UFL
            { x: -1, y: -1, z: 1 }, // ULB
            { x: 1, y: -1, z: 1 }, // UBR
            { x: 1, y: 1, z: -1 }, // DFR
            { x: -1, y: 1, z: -1 }, // DLF
            { x: -1, y: 1, z: 1 }, // DBL
            { x: 1, y: 1, z: 1 }, // DRB
          ];

          const edgePositions = [
            { x: 1, y: -1, z: 0 }, // UR
            { x: 0, y: -1, z: -1 }, // UF
            { x: -1, y: -1, z: 0 }, // UL
            { x: 0, y: -1, z: 1 }, // UB
            { x: 1, y: 1, z: 0 }, // DR
            { x: 0, y: 1, z: -1 }, // DF
            { x: -1, y: 1, z: 0 }, // DL
            { x: 0, y: 1, z: 1 }, // DB
            { x: 1, y: 0, z: -1 }, // FR
            { x: -1, y: 0, z: -1 }, // FL
            { x: -1, y: 0, z: 1 }, // BL
            { x: 1, y: 0, z: 1 }, // BR
          ];

          // Draw center stickers
          const centers = [
            { pos: { x: 0, y: -1, z: 0 }, color: 'white' }, // U
            { pos: { x: 0, y: 1, z: 0 }, color: 'yellow' }, // D
            { pos: { x: 1, y: 0, z: 0 }, color: 'red' }, // R
            { pos: { x: -1, y: 0, z: 0 }, color: 'orange' }, // L
            { pos: { x: 0, y: 0, z: -1 }, color: 'green' }, // F
            { pos: { x: 0, y: 0, z: 1 }, color: 'blue' }, // B
          ];

          // Collect all stickers with their z-depth
          const stickers = [];

          // Add center stickers
          centers.forEach(center => {
            const normal = center.pos;
            const tangent1 = normal.x !== 0 ? { x: 0, y: 1, z: 0 } : { x: 1, y: 0, z: 0 };
            const tangent2 = {
              x: normal.y * tangent1.z - normal.z * tangent1.y,
              y: normal.z * tangent1.x - normal.x * tangent1.z,
              z: normal.x * tangent1.y - normal.y * tangent1.x,
            };

            const size = 0.333; // 1/3 of cube edge
            const faceDistance = 1.01; // Slightly outside the cube center
            const shouldAnimate =
              this.currentAnimation && this.isPieceAffectedByMove('center', center.pos, this.currentAnimation.move);

            const corners = [
              this.project3D(
                center.pos.x * faceDistance + tangent1.x * size + tangent2.x * size,
                center.pos.y * faceDistance + tangent1.y * size + tangent2.y * size,
                center.pos.z * faceDistance + tangent1.z * size + tangent2.z * size,
                shouldAnimate,
              ),
              this.project3D(
                center.pos.x * faceDistance - tangent1.x * size + tangent2.x * size,
                center.pos.y * faceDistance - tangent1.y * size + tangent2.y * size,
                center.pos.z * faceDistance - tangent1.z * size + tangent2.z * size,
                shouldAnimate,
              ),
              this.project3D(
                center.pos.x * faceDistance - tangent1.x * size - tangent2.x * size,
                center.pos.y * faceDistance - tangent1.y * size - tangent2.y * size,
                center.pos.z * faceDistance - tangent1.z * size - tangent2.z * size,
                shouldAnimate,
              ),
              this.project3D(
                center.pos.x * faceDistance + tangent1.x * size - tangent2.x * size,
                center.pos.y * faceDistance + tangent1.y * size - tangent2.y * size,
                center.pos.z * faceDistance + tangent1.z * size - tangent2.z * size,
                shouldAnimate,
              ),
            ];

            const avgZ = (corners[0].z + corners[1].z + corners[2].z + corners[3].z) / 4;
            stickers.push({ corners, color: center.color, z: avgZ });
          });

          // Add edge stickers
          this.cube.edges.forEach((edge, index) => {
            const pos = edgePositions[index];
            const colors = edge.colors;
            const ori = edge.orientation;

            // Determine which faces this edge touches
            const facesTouchingEdge = [];
            if (Math.abs(pos.y) > 0.5) facesTouchingEdge.push(pos.y > 0 ? 'D' : 'U');
            if (Math.abs(pos.x) > 0.5) facesTouchingEdge.push(pos.x > 0 ? 'R' : 'L');
            if (Math.abs(pos.z) > 0.5) facesTouchingEdge.push(pos.z > 0 ? 'B' : 'F');

            // Draw stickers
            facesTouchingEdge.forEach((face, i) => {
              // For edges on the middle layer (FR, FL, BL, BR), we need to adjust the color mapping
              let colorIndex;
              if (index >= 8 && index <= 11) {
                // Middle layer edges - first color goes to F/B face, second to R/L face
                if (face === 'F' || face === 'B') {
                  colorIndex = ori;
                } else {
                  colorIndex = 1 - ori;
                }
              } else {
                // Top/bottom layer edges - standard mapping
                colorIndex = (i + ori) % 2;
              }
              const color = colors[colorIndex];

              let stickerCorners;
              const size = 0.333; // 1/3 of cube edge
              const faceDistance = 1.01; // Slightly outside the cube center
              const shouldAnimate =
                this.currentAnimation && this.isPieceAffectedByMove('edge', pos, this.currentAnimation.move);

              if (face === 'U' || face === 'D') {
                const y = (face === 'U' ? -1 : 1) * faceDistance;
                const xCenter = pos.x * 0.667;
                const zCenter = pos.z * 0.667;
                stickerCorners = [
                  this.project3D(xCenter + size, y, zCenter + size, shouldAnimate),
                  this.project3D(xCenter - size, y, zCenter + size, shouldAnimate),
                  this.project3D(xCenter - size, y, zCenter - size, shouldAnimate),
                  this.project3D(xCenter + size, y, zCenter - size, shouldAnimate),
                ];
              } else if (face === 'R' || face === 'L') {
                const x = (face === 'R' ? 1 : -1) * faceDistance;
                const yCenter = pos.y * 0.667;
                const zCenter = pos.z * 0.667;
                stickerCorners = [
                  this.project3D(x, yCenter + size, zCenter + size, shouldAnimate),
                  this.project3D(x, yCenter - size, zCenter + size, shouldAnimate),
                  this.project3D(x, yCenter - size, zCenter - size, shouldAnimate),
                  this.project3D(x, yCenter + size, zCenter - size, shouldAnimate),
                ];
              } else {
                const z = (face === 'F' ? -1 : 1) * faceDistance;
                const xCenter = pos.x * 0.667;
                const yCenter = pos.y * 0.667;
                stickerCorners = [
                  this.project3D(xCenter + size, yCenter + size, z, shouldAnimate),
                  this.project3D(xCenter - size, yCenter + size, z, shouldAnimate),
                  this.project3D(xCenter - size, yCenter - size, z, shouldAnimate),
                  this.project3D(xCenter + size, yCenter - size, z, shouldAnimate),
                ];
              }

              const avgZ = stickerCorners.reduce((sum, c) => sum + c.z, 0) / 4;
              stickers.push({ corners: stickerCorners, color, z: avgZ });
            });
          });

          // Add corner stickers
          this.cube.corners.forEach((corner, index) => {
            const pos = cornerPositions[index];
            const colors = corner.colors;
            const ori = corner.orientation;

            // Map each face to its color based on position
            const cornerMappings = [
              ['U', 'R', 'F'], // URF
              ['U', 'F', 'L'], // UFL
              ['U', 'L', 'B'], // ULB
              ['U', 'B', 'R'], // UBR
              ['D', 'F', 'R'], // DFR
              ['D', 'L', 'F'], // DLF
              ['D', 'B', 'L'], // DBL
              ['D', 'R', 'B'], // DRB
            ];

            const faceColorMap = Object.fromEntries(cornerMappings[index].map((face, i) => [face, colors[i]]));

            // Apply orientation
            // Define proper rotation order for each corner position
            const cornerRotationOrders = {
              0: ['U', 'R', 'F'], // URF
              1: ['U', 'F', 'L'], // UFL
              2: ['U', 'L', 'B'], // ULB
              3: ['U', 'B', 'R'], // UBR
              4: ['D', 'F', 'R'], // DFR
              5: ['D', 'L', 'F'], // DLF
              6: ['D', 'B', 'L'], // DBL
              7: ['D', 'R', 'B'], // DRB
            };

            const rotationOrder = cornerRotationOrders[index];
            const rotatedMap = Object.fromEntries(
              rotationOrder.map((face, i) => [face, faceColorMap[rotationOrder[(i + ori) % 3]]]),
            );

            // Draw stickers for each face this corner touches
            const facesToDraw = [];
            if (pos.y < 0) facesToDraw.push('U');
            else facesToDraw.push('D');
            if (pos.x > 0) facesToDraw.push('R');
            else facesToDraw.push('L');
            if (pos.z < 0) facesToDraw.push('F');
            else facesToDraw.push('B');

            facesToDraw.forEach(face => {
              const color = rotatedMap[face];

              let stickerCorners;
              const size = 0.333;
              const faceDistance = 1.01;
              const shouldAnimate =
                this.currentAnimation && this.isPieceAffectedByMove('corner', pos, this.currentAnimation.move);

              if (face === 'U' || face === 'D') {
                const y = (face === 'U' ? -1 : 1) * faceDistance;
                const xSign = pos.x > 0 ? 1 : -1;
                const zSign = pos.z > 0 ? 1 : -1;
                const xCenter = xSign * 0.667;
                const zCenter = zSign * 0.667;
                stickerCorners = [
                  this.project3D(xCenter + xSign * size, y, zCenter + zSign * size, shouldAnimate),
                  this.project3D(xCenter - xSign * size, y, zCenter + zSign * size, shouldAnimate),
                  this.project3D(xCenter - xSign * size, y, zCenter - zSign * size, shouldAnimate),
                  this.project3D(xCenter + xSign * size, y, zCenter - zSign * size, shouldAnimate),
                ];
              } else if (face === 'R' || face === 'L') {
                const x = (face === 'R' ? 1 : -1) * faceDistance;
                const ySign = pos.y > 0 ? 1 : -1;
                const zSign = pos.z > 0 ? 1 : -1;
                const yCenter = ySign * 0.667;
                const zCenter = zSign * 0.667;
                stickerCorners = [
                  this.project3D(x, yCenter + ySign * size, zCenter + zSign * size, shouldAnimate),
                  this.project3D(x, yCenter - ySign * size, zCenter + zSign * size, shouldAnimate),
                  this.project3D(x, yCenter - ySign * size, zCenter - zSign * size, shouldAnimate),
                  this.project3D(x, yCenter + ySign * size, zCenter - zSign * size, shouldAnimate),
                ];
              } else {
                const z = (face === 'F' ? -1 : 1) * faceDistance;
                const xSign = pos.x > 0 ? 1 : -1;
                const ySign = pos.y > 0 ? 1 : -1;
                const xCenter = xSign * 0.667;
                const yCenter = ySign * 0.667;
                stickerCorners = [
                  this.project3D(xCenter + xSign * size, yCenter + ySign * size, z, shouldAnimate),
                  this.project3D(xCenter - xSign * size, yCenter + ySign * size, z, shouldAnimate),
                  this.project3D(xCenter - xSign * size, yCenter - ySign * size, z, shouldAnimate),
                  this.project3D(xCenter + xSign * size, yCenter - ySign * size, z, shouldAnimate),
                ];
              }

              const avgZ = stickerCorners.reduce((sum, c) => sum + c.z, 0) / 4;
              stickers.push({ corners: stickerCorners, color, z: avgZ });
            });
          });

          // Sort stickers by z-depth (back to front)
          stickers.sort((a, b) => b.z - a.z);

          // Draw all stickers
          stickers.forEach(sticker => {
            this.drawSticker(sticker.corners, sticker.color);
          });
        }
      }

      // Initialize
      const cube = new RubiksCube();
      const renderer = new CubeRenderer(document.getElementById('canvas'), cube);

      // Scramble function
      async function scrambleCube() {
        const moves = ['U', "U'", 'D', "D'", 'R', "R'", 'L', "L'", 'F', "F'", 'B', "B'"];
        const scrambleLength = 30 + Math.floor(Math.random() * 11);

        for (let i = 0; i < scrambleLength; i++) {
          const randomMove = moves[Math.floor(Math.random() * moves.length)];
          await renderer.animateMove(randomMove);
        }
      }

      // Reset function
      function resetCube() {
        cube.reset();
        renderer.render();
      }

      // Reset orientation function
      function resetOrientation() {
        renderer.orientation = [0.1, 0.8, 0.1, 0.6];
        renderer.render();
      }

      // Initial render
      renderer.render();
    </script>
  </body>
</html>
