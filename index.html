<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rubik's Cube Simulator</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
      }

      .main-container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .canvas-with-rotation {
        position: relative;
        display: flex;
        justify-content: center;
      }

      .canvas-container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #canvas {
        border: 1px solid #ccc;
        background-color: #000;
        cursor: grab;
      }

      #canvas:active {
        cursor: grabbing;
      }

      .controls {
        margin-top: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #45a049;
      }

      .face-buttons {
        display: flex;
        gap: 5px;
      }

      .face-buttons button {
        background-color: #2196f3;
      }

      .face-buttons button:hover {
        background-color: #0b7dda;
      }

      .reorientation-buttons button {
        background-color: #9c27b0;
      }

      .reorientation-buttons button:hover {
        background-color: #7b1fa2;
      }

      .reorientation-buttons {
        display: flex;
        gap: 5px;
      }

      .slice-buttons {
        display: flex;
        gap: 5px;
      }

      .slice-buttons button {
        background-color: #ff5722;
        font-size: 14px;
        min-width: 50px;
      }

      .slice-buttons button:hover {
        background-color: #e64a19;
      }

      .rotation-controls {
        position: absolute;
        right: -90px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }

      .rotation-button {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: #ff9800;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s;
        user-select: none;
      }

      .rotation-button:hover {
        background-color: #e68900;
      }

      .rotation-button:active {
        background-color: #cc7a00;
      }

      .rotation-button svg {
        width: 30px;
        height: 30px;
        fill: white;
      }

      #reset-orientation-btn {
        background-color: #9c27b0;
      }

      #reset-orientation-btn:hover {
        background-color: #7b1fa2;
      }

      #reset-orientation-btn:active {
        background-color: #6a1b9a;
      }

      .sequence-input {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
      }

      #move-sequence {
        padding: 8px 12px;
        font-size: 14px;
        border: 2px solid #ccc;
        border-radius: 5px;
        width: 400px;
        font-family: 'Courier New', monospace;
        background-color: white;
        transition: border-color 0.3s;
      }

      #move-sequence:focus {
        outline: none;
        border-color: #4caf50;
      }

      .sequence-input button {
        padding: 8px 16px;
        font-size: 14px;
      }

      .error-dialog {
        border: none;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        padding: 20px;
        max-width: 400px;
        text-align: center;
      }

      .error-dialog::backdrop {
        background-color: rgba(0, 0, 0, 0.5);
      }

      .error-dialog h3 {
        color: #e53e3e;
        margin-top: 0;
      }

      .error-dialog button {
        background-color: #e53e3e;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 10px;
      }

      .error-dialog button:hover {
        background-color: #c53030;
      }
    </style>
  </head>
  <body>
    <h1>Rubik's Cube Simulator</h1>
    
    <div class="main-container">
      <div class="canvas-container">
        <div class="canvas-with-rotation">
          <canvas id="canvas" width="600" height="600"></canvas>
          
          <div class="rotation-controls">
            <button class="rotation-button" id="counterclockwise-btn" title="Hold to rotate cube counterclockwise">
              <svg viewBox="0 0 24 24">
                <path d="M12 6V9l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6z" fill="white"/>
              </svg>
            </button>
            <button class="rotation-button" id="clockwise-btn" title="Hold to rotate cube clockwise">
              <svg viewBox="0 0 24 24">
                <path d="M12 6V9l-4-4 4-4v3c4.42 0 8 3.58 8 8 0 1.57-.46 3.03-1.24 4.26L17.3 14.8c.45-.83.7-1.79.7-2.8 0-3.31-2.69-6-6-6z" fill="white"/>
              </svg>
            </button>
            <button class="rotation-button" id="reset-orientation-btn" onclick="resetOrientation()" title="Reset cube orientation to default view">
              <svg viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z" fill="white"/>
              </svg>
            </button>
          </div>
        </div>

        <div class="controls">
          <div class="face-buttons">
            <button onclick="renderer.animateVisualMove('U')">U</button>
            <button onclick="renderer.animateVisualMove('U\'')">U'</button>
            <button onclick="renderer.animateVisualMove('D')">D</button>
            <button onclick="renderer.animateVisualMove('D\'')">D'</button>
            <button onclick="renderer.animateVisualMove('R')">R</button>
            <button onclick="renderer.animateVisualMove('R\'')">R'</button>
            <button onclick="renderer.animateVisualMove('L')">L</button>
            <button onclick="renderer.animateVisualMove('L\'')">L'</button>
            <button onclick="renderer.animateVisualMove('F')">F</button>
            <button onclick="renderer.animateVisualMove('F\'')">F'</button>
            <button onclick="renderer.animateVisualMove('B')">B</button>
            <button onclick="renderer.animateVisualMove('B\'')">B'</button>
          </div>
        </div>

        <div class="controls">
          <div class="reorientation-buttons">
            <button onclick="renderer.animateVisualMove('x')">x</button>
            <button onclick="renderer.animateVisualMove('x\'')">x'</button>
            <button onclick="renderer.animateVisualMove('y')">y</button>
            <button onclick="renderer.animateVisualMove('y\'')">y'</button>
            <button onclick="renderer.animateVisualMove('z')">z</button>
            <button onclick="renderer.animateVisualMove('z\'')">z'</button>
          </div>
        </div>

        <div class="controls">
          <div class="slice-buttons">
            <button onclick="renderer.animateVisualMove('M')">M</button>
            <button onclick="renderer.animateVisualMove('M\'')">M'</button>
            <button onclick="renderer.animateVisualMove('E')">E</button>
            <button onclick="renderer.animateVisualMove('E\'')">E'</button>
            <button onclick="renderer.animateVisualMove('S')">S</button>
            <button onclick="renderer.animateVisualMove('S\'')">S'</button>
          </div>
        </div>

        <div class="controls">
          <div class="sequence-input">
            <input type="text" id="move-sequence" placeholder="Enter moves: R U R' U' R' F R2 U' R' U' R U R' F'" />
            <button onclick="executeMoveSequence()">Execute</button>
          </div>
        </div>

        <div class="controls">
          <button onclick="scrambleCube()">Scramble</button>
          <button onclick="resetCube()">Reset</button>
        </div>
      </div>
    </div>

    <dialog id="error-dialog" class="error-dialog">
      <h3>Invalid Move Sequence</h3>
      <p id="error-message"></p>
      <button onclick="hideErrorModal()">OK</button>
    </dialog>

    <script>
      class RubiksCube {
        constructor() {
          this.reset();
        }

        reset() {
          this.corners = [
            { id: 0, orientation: 0, colors: ['white', 'red', 'green'] }, // URF
            { id: 1, orientation: 0, colors: ['white', 'green', 'orange'] }, // UFL
            { id: 2, orientation: 0, colors: ['white', 'orange', 'blue'] }, // ULB
            { id: 3, orientation: 0, colors: ['white', 'blue', 'red'] }, // UBR
            { id: 4, orientation: 0, colors: ['yellow', 'green', 'red'] }, // DFR
            { id: 5, orientation: 0, colors: ['yellow', 'orange', 'green'] }, // DLF
            { id: 6, orientation: 0, colors: ['yellow', 'blue', 'orange'] }, // DBL
            { id: 7, orientation: 0, colors: ['yellow', 'red', 'blue'] }, // DRB
          ];

          this.edges = [
            { id: 0, orientation: 0, colors: ['white', 'red'] }, // UR
            { id: 1, orientation: 0, colors: ['white', 'green'] }, // UF
            { id: 2, orientation: 0, colors: ['white', 'orange'] }, // UL
            { id: 3, orientation: 0, colors: ['white', 'blue'] }, // UB
            { id: 4, orientation: 0, colors: ['yellow', 'red'] }, // DR
            { id: 5, orientation: 0, colors: ['yellow', 'green'] }, // DF
            { id: 6, orientation: 0, colors: ['yellow', 'orange'] }, // DL
            { id: 7, orientation: 0, colors: ['yellow', 'blue'] }, // DB
            { id: 8, orientation: 0, colors: ['green', 'red'] }, // FR
            { id: 9, orientation: 0, colors: ['green', 'orange'] }, // FL
            { id: 10, orientation: 0, colors: ['blue', 'orange'] }, // BL
            { id: 11, orientation: 0, colors: ['blue', 'red'] }, // BR
          ];
        }

        // Apply a move
        move(notation) {
          const moveMap = {
            U: () => this.U(),
            "U'": () => this.Uprime(),
            U2: () => {
              this.U();
              this.U();
            },
            D: () => this.D(),
            "D'": () => this.Dprime(),
            D2: () => {
              this.D();
              this.D();
            },
            R: () => this.R(),
            "R'": () => this.Rprime(),
            R2: () => {
              this.R();
              this.R();
            },
            L: () => this.L(),
            "L'": () => this.Lprime(),
            L2: () => {
              this.L();
              this.L();
            },
            F: () => this.F(),
            "F'": () => this.Fprime(),
            F2: () => {
              this.F();
              this.F();
            },
            B: () => this.B(),
            "B'": () => this.Bprime(),
            B2: () => {
              this.B();
              this.B();
            },
          };

          if (moveMap[notation]) {
            moveMap[notation]();
          }
        }

        cyclePieces(pieces, cycle, oriChange = 0) {
          const isCorner = pieces === this.corners;
          const first = pieces[cycle[0]];
          for (let i = cycle.length - 1; i >= 0; --i) {
            const piece = i === 0 ? first : pieces[cycle[i]];
            const newPos = cycle[(i + 1) % cycle.length];
            const dist = newPos - cycle[i];
            const sign = dist % 2 === 0 ? 1 : -1;
            piece.orientation = ((isCorner ? 3 : 2) + piece.orientation + sign * oriChange) % (isCorner ? 3 : 2);
            pieces[newPos] = piece;
          }
        }

        // Check if the cube is in solved state
        isSolved() {
          // Check if all corners are in correct positions with correct orientation
          for (let i = 0; i < this.corners.length; i++) {
            const corner = this.corners[i];
            if (corner.id !== i || corner.orientation !== 0) {
              return false;
            }
          }
          
          // Check if all edges are in correct positions with correct orientation
          for (let i = 0; i < this.edges.length; i++) {
            const edge = this.edges[i];
            if (edge.id !== i || edge.orientation !== 0) {
              return false;
            }
          }
          
          return true;
        }

        // Face moves
        U() {
          this.cyclePieces(this.corners, [0, 1, 2, 3], 0);
          this.cyclePieces(this.edges, [0, 1, 2, 3], 0);
        }

        Uprime() {
          this.cyclePieces(this.corners, [3, 2, 1, 0], 0);
          this.cyclePieces(this.edges, [3, 2, 1, 0], 0);
        }

        D() {
          this.cyclePieces(this.corners, [4, 7, 6, 5], 0);
          this.cyclePieces(this.edges, [4, 7, 6, 5], 0);
        }

        Dprime() {
          this.cyclePieces(this.corners, [5, 6, 7, 4], 0);
          this.cyclePieces(this.edges, [5, 6, 7, 4], 0);
        }

        R() {
          this.cyclePieces(this.corners, [0, 3, 7, 4], 1);
          this.cyclePieces(this.edges, [0, 11, 4, 8], 0);
        }

        Rprime() {
          this.cyclePieces(this.corners, [4, 7, 3, 0], 2);
          this.cyclePieces(this.edges, [8, 4, 11, 0], 0);
        }

        L() {
          this.cyclePieces(this.corners, [2, 1, 5, 6], 1);
          this.cyclePieces(this.edges, [2, 9, 6, 10], 0);
        }

        Lprime() {
          this.cyclePieces(this.corners, [6, 5, 1, 2], 2);
          this.cyclePieces(this.edges, [10, 6, 9, 2], 0);
        }

        F() {
          this.cyclePieces(this.corners, [1, 0, 4, 5], 1);
          this.cyclePieces(this.edges, [1, 8, 5, 9], 1);
        }

        Fprime() {
          this.cyclePieces(this.corners, [5, 4, 0, 1], 2);
          this.cyclePieces(this.edges, [9, 5, 8, 1], 1);
        }

        B() {
          this.cyclePieces(this.corners, [3, 2, 6, 7], 1);
          this.cyclePieces(this.edges, [3, 10, 7, 11], 1);
        }

        Bprime() {
          this.cyclePieces(this.corners, [7, 6, 2, 3], 2);
          this.cyclePieces(this.edges, [11, 7, 10, 3], 1);
        }
      }

      /**
       * A collection of self-contained math utilities for 3D rotation.
       * Quaternions are represented as [x, y, z, w].
       * 4x4 Matrices are represented as a 16-element Float32Array in column-major order.
       */
      const Math3D = {
        // --- Quaternion Functions ---

        /** Creates an identity quaternion [0, 0, 0, 1] */
        quat_create: function () {
          return [0, 0, 0, 1];
        },

        /**
         * Creates a quaternion from a rotation around an axis.
         * @param {Float32Array} out The receiving quaternion.
         * @param {Array<number>} axis The axis of rotation.
         * @param {number} rad The angle of rotation in radians.
         */
        quat_fromAxisAngle: function (out, axis, rad) {
          const halfAngle = rad / 2;
          const s = Math.sin(halfAngle);
          out[0] = axis[0] * s;
          out[1] = axis[1] * s;
          out[2] = axis[2] * s;
          out[3] = Math.cos(halfAngle);
          return out;
        },

        /**
         * Multiplies two quaternions. Order matters: a * b applies rotation b then a.
         * @param {Float32Array} out The receiving quaternion.
         * @param {Float32Array} a The first operand.
         * @param {Float32Array} b The second operand.
         */
        quat_multiply: function (out, a, b) {
          const ax = a[0],
            ay = a[1],
            az = a[2],
            aw = a[3];
          const bx = b[0],
            by = b[1],
            bz = b[2],
            bw = b[3];
          out[0] = ax * bw + aw * bx + ay * bz - az * by;
          out[1] = ay * bw + aw * by + az * bx - ax * bz;
          out[2] = az * bw + aw * bz + ax * by - ay * bx;
          out[3] = aw * bw - ax * bx - ay * by - az * bz;
          return out;
        },

        /**
         * Normalizes a quaternion.
         * @param {Float32Array} out The receiving quaternion.
         * @param {Float32Array} q The quaternion to normalize.
         */
        quat_normalize: function (out, q) {
          let len = q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3];
          if (len > 0) {
            len = 1 / Math.sqrt(len);
          }
          out[0] = q[0] * len;
          out[1] = q[1] * len;
          out[2] = q[2] * len;
          out[3] = q[3] * len;
          return out;
        },

        // --- Matrix Functions ---

        /**
         * Creates a 4x4 rotation matrix from a quaternion.
         * @param {Float32Array} out The receiving 16-element matrix.
         * @param {Float32Array} q The quaternion.
         */
        mat4_fromQuat: function (out, q) {
          const x = q[0],
            y = q[1],
            z = q[2],
            w = q[3];
          const x2 = x + x,
            y2 = y + y,
            z2 = z + z;
          const xx = x * x2,
            xy = x * y2,
            xz = x * z2;
          const yy = y * y2,
            yz = y * z2,
            zz = z * z2;
          const wx = w * x2,
            wy = w * y2,
            wz = w * z2;

          out[0] = 1 - (yy + zz);
          out[1] = xy + wz;
          out[2] = xz - wy;
          out[3] = 0;

          out[4] = xy - wz;
          out[5] = 1 - (xx + zz);
          out[6] = yz + wx;
          out[7] = 0;

          out[8] = xz + wy;
          out[9] = yz - wx;
          out[10] = 1 - (xx + yy);
          out[11] = 0;

          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
          out[15] = 1;
          return out;
        },

        /**
         * Transforms a 3D vector by a quaternion.
         * @param {Array<number>} out The receiving 3-element vector.
         * @param {Array<number>} v The 3-element vector to transform.
         * @param {Float32Array} q The quaternion to rotate by.
         */
        vec3_transformQuat: function (out, v, q) {
          // This is a standard, optimized method for vector-quaternion rotation.
          const qx = q[0],
            qy = q[1],
            qz = q[2],
            qw = q[3];
          const vx = v[0],
            vy = v[1],
            vz = v[2];

          // Calculate uv = 2 * cross(q.xyz, v)
          const uvx = 2 * (qy * vz - qz * vy);
          const uvy = 2 * (qz * vx - qx * vz);
          const uvz = 2 * (qx * vy - qy * vx);

          // out = v + q.w * uv + cross(q.xyz, uv)
          out[0] = vx + qw * uvx + (qy * uvz - qz * uvy);
          out[1] = vy + qw * uvy + (qz * uvx - qx * uvz);
          out[2] = vz + qw * uvz + (qx * uvy - qy * uvx);
          return out;
        },
      };

      // 3D Renderer
      class CubeRenderer {
        constructor(canvas, cube) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.cube = cube;
          this.orientation = [0.0991, 0.7921, 0.0990, 0.5941];
          this.scale = 100;

          this.setupInteraction();

          this.animating = false;
          this.animationQueue = [];
          this.animationProgress = 0;
          this.animationDuration = 300; // milliseconds
          this.currentAnimation = null;
        }

        setupInteraction() {
          let isDragging = false;
          let lastX, lastY;

          this.canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
          });

          const rotationSpeed = 0.008;

          window.addEventListener('mousemove', e => {
            if (!isDragging) return;

            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;

            // Create a temporary quaternion to represent the new rotation
            const deltaQuat = Math3D.quat_create();

            // Create a rotation from the horizontal drag (around the Y-axis)
            const rotY = Math3D.quat_fromAxisAngle(Math3D.quat_create(), [0, 1, 0], -deltaX * rotationSpeed);

            // Create a rotation from the vertical drag (around the X-axis)
            const rotX = Math3D.quat_fromAxisAngle(Math3D.quat_create(), [1, 0, 0], deltaY * rotationSpeed);

            // Combine the two new rotations (Y rotation then X rotation)
            Math3D.quat_multiply(deltaQuat, rotY, rotX);

            // Combine this new delta rotation with the cube's current orientation.
            // The order is crucial: new_orientation = delta_rotation * current_orientation
            // This applies the drag relative to the screen/view axes.
            Math3D.quat_multiply(this.orientation, deltaQuat, this.orientation);

            // Normalize the result to prevent floating point errors from accumulating
            Math3D.quat_normalize(this.orientation, this.orientation);

            lastX = e.clientX;
            lastY = e.clientY;

            this.render();
          });

          window.addEventListener('mouseup', () => {
            isDragging = false;
          });
        }

        // Map visual face positions to logical faces based on current rotation
        getVisualToLogicalMapping() {
          // Define the standard face normals for each logical face
          const faceNormals = {
            U: [0, -1, 0], // Up face points down in our coordinate system
            D: [0, 1, 0], // Down face points up
            R: [1, 0, 0], // Right face points right
            L: [-1, 0, 0], // Left face points left
            F: [0, 0, -1], // Front face points toward viewer
            B: [0, 0, 1], // Back face points away from viewer
          };

          // Define visual directions we want to check against
          const visualDirections = {
            visualUp: [0, -1, 0], // Visual up is negative Y
            visualDown: [0, 1, 0], // Visual down is positive Y
            visualRight: [1, 0, 0], // Visual right is positive X
            visualLeft: [-1, 0, 0], // Visual left is negative X
            visualFront: [0, 0, -1], // Visual front is negative Z
            visualBack: [0, 0, 1], // Visual back is positive Z
          };

          const mapping = {};

          // For each visual direction, find which logical face is closest to it
          Object.entries(visualDirections).forEach(([visualPos, visualDir]) => {
            let bestMatch = null;
            let bestDot = -2; // Start with impossible dot product value

            // Check each logical face
            Object.entries(faceNormals).forEach(([logicalFace, normal]) => {
              // Transform the logical face normal by the current orientation
              const transformedNormal = [0, 0, 0];
              Math3D.vec3_transformQuat(transformedNormal, normal, this.orientation);

              // Calculate dot product to find how aligned they are
              const dot =
                transformedNormal[0] * visualDir[0] +
                transformedNormal[1] * visualDir[1] +
                transformedNormal[2] * visualDir[2];

              // Keep track of the best match
              if (dot > bestDot) {
                bestDot = dot;
                bestMatch = logicalFace;
              }
            });

            mapping[visualPos] = bestMatch;
          });

          return mapping;
        }

        // Convert visual move notation to logical move notation
        visualMoveToLogical(visualMove) {
          const mapping = this.getVisualToLogicalMapping();
          const isPrime = visualMove.includes("'");
          const baseFace = visualMove.charAt(0);

          let logicalFace;
          switch (baseFace) {
            case 'U':
              logicalFace = mapping.visualUp;
              break;
            case 'D':
              logicalFace = mapping.visualDown;
              break;
            case 'R':
              logicalFace = mapping.visualRight;
              break;
            case 'L':
              logicalFace = mapping.visualLeft;
              break;
            case 'F':
              logicalFace = mapping.visualFront;
              break;
            case 'B':
              logicalFace = mapping.visualBack;
              break;
            default:
              throw new Error(`not a move: ${baseFace}`);
          }

          return logicalFace + (isPrime ? "'" : '');
        }

        // Reorientation moves - these update the cube's visual orientation
        animateReorientationMove(move) {
          return new Promise(resolve => {
            this.animationQueue.push({ 
              move, 
              resolve,
              isReorientationMove: true 
            });
            if (!this.animating) {
              this.processAnimationQueue();
            }
          });
        }
        
        // Helper function to get face normal in world space
        getFaceNormal(logicalFace) {
          const faceNormals = {
            U: [0, -1, 0],
            D: [0, 1, 0], 
            R: [1, 0, 0],
            L: [-1, 0, 0],
            F: [0, 0, -1],
            B: [0, 0, 1]
          };
          
          const normal = faceNormals[logicalFace];
          const transformedNormal = [0, 0, 0];
          Math3D.vec3_transformQuat(transformedNormal, normal, this.orientation);
          return transformedNormal;
        }

        animateMove(move) {
          return new Promise(resolve => {
            this.animationQueue.push({ move, resolve });
            if (!this.animating) {
              this.processAnimationQueue();
            }
          });
        }

        // Animate a move based on visual orientation
        animateVisualMove(visualMove) {
          const baseFace = visualMove.charAt(0);
          
          // Handle reorientation moves (x, y, z)
          if (['x', 'y', 'z'].includes(baseFace)) {
            return this.animateReorientationMove(visualMove);
          }
          
          // Handle slice moves (M, E, S)
          if (['M', 'E', 'S'].includes(baseFace)) {
            return this.animateSliceMove(visualMove);
          }
          
          // Handle regular face moves
          return this.animateMove(visualMove);
        }

        // Animate slice moves (M, E, S)
        animateSliceMove(move) {
          if (!['M', "M'", 'E', "E'", 'S', "S'"].includes(move)) {
            throw new Error(`unknown slice move ${move}`);
          }
          let reorientationMove;

          // Determine corresponding reorientation move
          if (move === 'M') {
            reorientationMove = "x";
          } else if (move === "M'") {
            reorientationMove = "x'";
          } else if (move === 'E') {
            reorientationMove = 'y';
          } else if (move === "E'") {
            reorientationMove = "y'";
          } else if (move === 'S') {
            reorientationMove = "z'";
          } else if (move === "S'") {
            reorientationMove = 'z';
          }
          
          return new Promise(resolve => {
            this.animationQueue.push({ 
              move,
              resolve,
              isSliceMove: true,
              isReorientationMove: true,
              reorientationMove,
            });
            if (!this.animating) {
              this.processAnimationQueue();
            }
          });
        }

        processAnimationQueue() {
          if (this.animationQueue.length === 0) {
            this.animating = false;
            this.render(); // Re-render to show solved indicator if applicable
            return;
          }

          this.animating = true;
          const { move, resolve, isSliceMove, isReorientationMove, reorientationMove } = this.animationQueue.shift();
          
          let processedMove = move;
          if (!isSliceMove && !isReorientationMove) {
            processedMove = this.visualMoveToLogical(move);
          }
          
          this.currentAnimation = { move: processedMove, resolve, startTime: Date.now(), isSliceMove, isReorientationMove };

          // For reorientation moves, set up the rotation data
          let reorientationData = null;
          if (isReorientationMove) {
            const moveToUse = reorientationMove || move; // Use reorientationMove if it's a combined move
            reorientationData = this.setupReorientationAnimation(moveToUse);
          }

          const animate = () => {
            const elapsed = Date.now() - this.currentAnimation.startTime;
            this.animationProgress = Math.min(elapsed / this.animationDuration, 1);

            // Handle reorientation animation
            if (this.currentAnimation.isReorientationMove) {
              this.updateReorientationAnimation(reorientationData, this.animationProgress);
            }

            this.render();

            if (this.animationProgress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Apply the actual move(s) to the cube state
              if (this.currentAnimation.isSliceMove) {
                // Convert slice moves back to dual face moves for cube state
                const sliceMove = this.currentAnimation.move;
                const dualFaceMoves = this.sliceToFaceMoves(sliceMove);
                this.cube.move(dualFaceMoves[0]);
                this.cube.move(dualFaceMoves[1]);
              } else if (!this.currentAnimation.isReorientationMove) {
                // Apply single face moves (reorientation moves don't change cube state)
                this.cube.move(this.currentAnimation.move);
              }
              // Note: Reorientation moves don't change cube state, only visual orientation
              // Final orientation is already set by updateReorientationAnimation
              this.animationProgress = 0;
              this.currentAnimation.resolve();
              this.currentAnimation = null;
              this.render();
              this.processAnimationQueue();
            }
          };

          animate();
        }

        sliceToFaceMoves(sliceMove) {
          // Convert slice moves to visual dual face moves
          const sliceToFaceMap = {
            'M': ['R', "L'"],    // M = R+L'
            "M'": ["R'", 'L'],     // M' = R'+L
            'E': ['U', "D'"],    // E = U+D'
            "E'": ["U'", 'D'],     // E' = U'+D
            'S': ["F'", 'B'],     // S = F'+B
            "S'": ['F', "B'"],     // S' = F+B'
          };
          
          const moves = sliceToFaceMap[sliceMove];
          if (!moves) {
            throw new Error(`Unknown slice move: ${sliceMove}`);
          }
          
          // Convert to logical moves based on current orientation
          return [
            this.visualMoveToLogical(moves[0]),
            this.visualMoveToLogical(moves[1])
          ];
        }

        setupReorientationAnimation(move) {
          const isPrime = move.includes("'");
          const baseFace = move.charAt(0);
          const mapping = this.getVisualToLogicalMapping();
          
          let axis;
          let direction = isPrime ? -1 : 1;
          
          // Determine the rotation axis based on current orientation
          switch (baseFace) {
            case 'x':
              // Rotate around R-L axis (current visual right to left)
              const rFace = mapping.visualRight;
              const lFace = mapping.visualLeft;
              // Get the axis by finding the vector between R and L face normals
              const rNormal = this.getFaceNormal(rFace);
              const lNormal = this.getFaceNormal(lFace);
              axis = [rNormal[0] - lNormal[0], rNormal[1] - lNormal[1], rNormal[2] - lNormal[2]];
              break;
            case 'y':
              // Rotate around U-D axis (current visual up to down)
              const uFace = mapping.visualUp;
              const dFace = mapping.visualDown;
              const uNormal = this.getFaceNormal(uFace);
              const dNormal = this.getFaceNormal(dFace);
              axis = [uNormal[0] - dNormal[0], uNormal[1] - dNormal[1], uNormal[2] - dNormal[2]];
              break;
            case 'z':
              // Rotate around F-B axis (current visual front to back)
              const fFace = mapping.visualFront;
              const bFace = mapping.visualBack;
              const fNormal = this.getFaceNormal(fFace);
              const bNormal = this.getFaceNormal(bFace);
              axis = [fNormal[0] - bNormal[0], fNormal[1] - bNormal[1], fNormal[2] - bNormal[2]];
              break;
          }
          
          // Normalize the axis
          const axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
          axis[0] /= axisLength;
          axis[1] /= axisLength;
          axis[2] /= axisLength;
          
          // Return reorientation animation data
          return {
            axis,
            totalRotation: direction * Math.PI / 2, // 90 degrees
            startOrientation: [...this.orientation]
          };
        }

        updateReorientationAnimation(reorientationData, animationProgress) {
          const { axis, totalRotation, startOrientation } = reorientationData;
          
          const currentAngle = totalRotation * animationProgress;
          
          // Create rotation quaternion for current progress
          const rotationQuat = Math3D.quat_fromAxisAngle(Math3D.quat_create(), axis, currentAngle);
          
          // Apply rotation to starting orientation
          Math3D.quat_multiply(this.orientation, rotationQuat, startOrientation);
          Math3D.quat_normalize(this.orientation, this.orientation);
        }

        getRotationMatrix(axis, angle) {
          const c = Math.cos(angle);
          const s = Math.sin(angle);

          if (axis === 'y') {
            return {
              x: (x, y, z) => x * c - z * s,
              y: (x, y, z) => y,
              z: (x, y, z) => x * s + z * c,
            };
          } else if (axis === 'x') {
            return {
              x: (x, y, z) => x,
              y: (x, y, z) => y * c - z * s,
              z: (x, y, z) => y * s + z * c,
            };
          } else if (axis === 'z') {
            return {
              x: (x, y, z) => x * c - y * s,
              y: (x, y, z) => x * s + y * c,
              z: (x, y, z) => z,
            };
          }
        }

        getAnimationRotation(move, piecePosition) {
          // Handle slice moves by converting to equivalent dual face moves
          if (['M', "M'", 'E', "E'", 'S', "S'"].includes(move)) {
            const faceMoves = this.sliceToFaceMoves(move);
            if (piecePosition) {
              if (this.isPieceAffectedBySingleMove(piecePosition, faceMoves[0])) {
                return this.getAnimationRotationForSingleMove(faceMoves[0]);
              } else if (this.isPieceAffectedBySingleMove(piecePosition, faceMoves[1])) {
                return this.getAnimationRotationForSingleMove(faceMoves[1]);
              }
            }
            return null;
          }

          return this.getAnimationRotationForSingleMove(move);
        }

        getAnimationRotationForSingleMove(move) {
          const face = move.charAt(0);
          const isPrime = move.includes("'");

          let axis, angle;
          if (face === 'U' || face === 'D') {
            axis = 'y';
            angle = (((face === 'U' ? -1 : 1) * (isPrime ? -1 : 1) * Math.PI) / 2) * this.animationProgress;
          } else if (face === 'R' || face === 'L') {
            axis = 'x';
            angle = (((face === 'R' ? 1 : -1) * (isPrime ? 1 : -1) * Math.PI) / 2) * this.animationProgress;
          } else if (face === 'F' || face === 'B') {
            axis = 'z';
            angle = (((face === 'B' ? -1 : 1) * (isPrime ? -1 : 1) * Math.PI) / 2) * this.animationProgress;
          } else {
            return null;
          }

          return this.getRotationMatrix(axis, angle);
        }

        isPieceAffectedByMove(pieceType, piecePos, move) {
          // Handle slice moves by converting to equivalent face moves
          if (['M', "M'", 'E', "E'", 'S', "S'"].includes(move)) {
            const faceMoves = this.sliceToFaceMoves(move);
            return this.isPieceAffectedBySingleMove(piecePos, faceMoves[0]) || 
                   this.isPieceAffectedBySingleMove(piecePos, faceMoves[1]);
          }

          return this.isPieceAffectedBySingleMove(piecePos, move);
        }

        isPieceAffectedBySingleMove(piecePos, move) {
          const face = move.charAt(0);

          // Use boundaries that match the actual cube structure
          if (face === 'U') return piecePos.y < -0.5;
          if (face === 'D') return piecePos.y > 0.5;
          if (face === 'R') return piecePos.x > 0.5;
          if (face === 'L') return piecePos.x < -0.5;
          if (face === 'F') return piecePos.z < -0.5;
          if (face === 'B') return piecePos.z > 0.5;

          return false;
        }

        project3D(x, y, z, applyAnimation, piecePosition = null) {
          // Apply animation rotation if active
          if (applyAnimation && this.currentAnimation) {
            const move = this.currentAnimation.move;
            
            // Get the appropriate rotation for this animation
            const rotation = this.getAnimationRotation(move, piecePosition);
            if (rotation) {
              const newX = rotation.x(x, y, z);
              const newY = rotation.y(x, y, z);
              const newZ = rotation.z(x, y, z);
              x = newX;
              y = newY;
              z = newZ;
            }
          }

          const rotatedPoint = [0, 0, 0];
          Math3D.vec3_transformQuat(rotatedPoint, [x, y, z], this.orientation);

          const x1 = rotatedPoint[0];
          const y1 = rotatedPoint[1];
          const z2 = rotatedPoint[2];

          // Project to 2D
          const perspective = 1000 / (1000 + z2);
          const projX = x1 * this.scale * perspective + this.canvas.width / 2;
          const projY = y1 * this.scale * perspective + this.canvas.height / 2;

          return { x: projX, y: projY, z: z2 };
        }

        drawSticker(corners, color) {
          this.ctx.beginPath();
          this.ctx.moveTo(corners[0].x, corners[0].y);
          for (let i = 1; i < corners.length; i++) {
            this.ctx.lineTo(corners[i].x, corners[i].y);
          }
          this.ctx.closePath();

          const colorMap = {
            white: '#FFFFFF',
            yellow: '#FFD500',
            red: '#B71234',
            orange: '#FF5800',
            green: '#009E60',
            blue: '#0051BA',
          };

          this.ctx.fillStyle = colorMap[color] || color;
          this.ctx.fill();
          this.ctx.strokeStyle = '#000';
          this.ctx.lineWidth = 2;
          this.ctx.stroke();
        }

        render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          const faces = [];

          // Define piece positions and orientations
          const cornerPositions = [
            { x: 1, y: -1, z: -1 }, // URF
            { x: -1, y: -1, z: -1 }, // UFL
            { x: -1, y: -1, z: 1 }, // ULB
            { x: 1, y: -1, z: 1 }, // UBR
            { x: 1, y: 1, z: -1 }, // DFR
            { x: -1, y: 1, z: -1 }, // DLF
            { x: -1, y: 1, z: 1 }, // DBL
            { x: 1, y: 1, z: 1 }, // DRB
          ];

          const edgePositions = [
            { x: 1, y: -1, z: 0 }, // UR
            { x: 0, y: -1, z: -1 }, // UF
            { x: -1, y: -1, z: 0 }, // UL
            { x: 0, y: -1, z: 1 }, // UB
            { x: 1, y: 1, z: 0 }, // DR
            { x: 0, y: 1, z: -1 }, // DF
            { x: -1, y: 1, z: 0 }, // DL
            { x: 0, y: 1, z: 1 }, // DB
            { x: 1, y: 0, z: -1 }, // FR
            { x: -1, y: 0, z: -1 }, // FL
            { x: -1, y: 0, z: 1 }, // BL
            { x: 1, y: 0, z: 1 }, // BR
          ];

          // Draw center stickers
          const centers = [
            { pos: { x: 0, y: -1, z: 0 }, color: 'white' }, // U
            { pos: { x: 0, y: 1, z: 0 }, color: 'yellow' }, // D
            { pos: { x: 1, y: 0, z: 0 }, color: 'red' }, // R
            { pos: { x: -1, y: 0, z: 0 }, color: 'orange' }, // L
            { pos: { x: 0, y: 0, z: -1 }, color: 'green' }, // F
            { pos: { x: 0, y: 0, z: 1 }, color: 'blue' }, // B
          ];

          // Collect all stickers with their z-depth
          const stickers = [];

          // Add center stickers
          centers.forEach(center => {
            const normal = center.pos;
            const tangent1 = normal.x !== 0 ? { x: 0, y: 1, z: 0 } : { x: 1, y: 0, z: 0 };
            const tangent2 = {
              x: normal.y * tangent1.z - normal.z * tangent1.y,
              y: normal.z * tangent1.x - normal.x * tangent1.z,
              z: normal.x * tangent1.y - normal.y * tangent1.x,
            };

            const size = 0.333; // 1/3 of cube edge
            const faceDistance = 1.01; // Slightly outside the cube center
            const shouldAnimate =
              this.currentAnimation && this.isPieceAffectedByMove('center', center.pos, this.currentAnimation.move);

            const corners = [
              this.project3D(
                center.pos.x * faceDistance + tangent1.x * size + tangent2.x * size,
                center.pos.y * faceDistance + tangent1.y * size + tangent2.y * size,
                center.pos.z * faceDistance + tangent1.z * size + tangent2.z * size,
                shouldAnimate,
                center.pos
              ),
              this.project3D(
                center.pos.x * faceDistance - tangent1.x * size + tangent2.x * size,
                center.pos.y * faceDistance - tangent1.y * size + tangent2.y * size,
                center.pos.z * faceDistance - tangent1.z * size + tangent2.z * size,
                shouldAnimate,
                center.pos
              ),
              this.project3D(
                center.pos.x * faceDistance - tangent1.x * size - tangent2.x * size,
                center.pos.y * faceDistance - tangent1.y * size - tangent2.y * size,
                center.pos.z * faceDistance - tangent1.z * size - tangent2.z * size,
                shouldAnimate,
                center.pos
              ),
              this.project3D(
                center.pos.x * faceDistance + tangent1.x * size - tangent2.x * size,
                center.pos.y * faceDistance + tangent1.y * size - tangent2.y * size,
                center.pos.z * faceDistance + tangent1.z * size - tangent2.z * size,
                shouldAnimate,
                center.pos
              ),
            ];

            const avgZ = (corners[0].z + corners[1].z + corners[2].z + corners[3].z) / 4;
            stickers.push({ corners, color: center.color, z: avgZ });
          });

          // Add edge stickers
          this.cube.edges.forEach((edge, index) => {
            const pos = edgePositions[index];
            const colors = edge.colors;
            const ori = edge.orientation;

            // Determine which faces this edge touches
            const facesTouchingEdge = [];
            if (Math.abs(pos.y) > 0.5) facesTouchingEdge.push(pos.y > 0 ? 'D' : 'U');
            if (Math.abs(pos.x) > 0.5) facesTouchingEdge.push(pos.x > 0 ? 'R' : 'L');
            if (Math.abs(pos.z) > 0.5) facesTouchingEdge.push(pos.z > 0 ? 'B' : 'F');

            // Draw stickers
            facesTouchingEdge.forEach((face, i) => {
              // For edges on the middle layer (FR, FL, BL, BR), we need to adjust the color mapping
              let colorIndex;
              if (index >= 8 && index <= 11) {
                // Middle layer edges - first color goes to F/B face, second to R/L face
                if (face === 'F' || face === 'B') {
                  colorIndex = ori;
                } else {
                  colorIndex = 1 - ori;
                }
              } else {
                // Top/bottom layer edges - standard mapping
                colorIndex = (i + ori) % 2;
              }
              const color = colors[colorIndex];

              let stickerCorners;
              const size = 0.333; // 1/3 of cube edge
              const faceDistance = 1.01; // Slightly outside the cube center
              const shouldAnimate =
                this.currentAnimation && this.isPieceAffectedByMove('edge', pos, this.currentAnimation.move);

              if (face === 'U' || face === 'D') {
                const y = (face === 'U' ? -1 : 1) * faceDistance;
                const xCenter = pos.x * 0.667;
                const zCenter = pos.z * 0.667;
                stickerCorners = [
                  this.project3D(xCenter + size, y, zCenter + size, shouldAnimate, pos),
                  this.project3D(xCenter - size, y, zCenter + size, shouldAnimate, pos),
                  this.project3D(xCenter - size, y, zCenter - size, shouldAnimate, pos),
                  this.project3D(xCenter + size, y, zCenter - size, shouldAnimate, pos),
                ];
              } else if (face === 'R' || face === 'L') {
                const x = (face === 'R' ? 1 : -1) * faceDistance;
                const yCenter = pos.y * 0.667;
                const zCenter = pos.z * 0.667;
                stickerCorners = [
                  this.project3D(x, yCenter + size, zCenter + size, shouldAnimate, pos),
                  this.project3D(x, yCenter - size, zCenter + size, shouldAnimate, pos),
                  this.project3D(x, yCenter - size, zCenter - size, shouldAnimate, pos),
                  this.project3D(x, yCenter + size, zCenter - size, shouldAnimate, pos),
                ];
              } else {
                const z = (face === 'F' ? -1 : 1) * faceDistance;
                const xCenter = pos.x * 0.667;
                const yCenter = pos.y * 0.667;
                stickerCorners = [
                  this.project3D(xCenter + size, yCenter + size, z, shouldAnimate, pos),
                  this.project3D(xCenter - size, yCenter + size, z, shouldAnimate, pos),
                  this.project3D(xCenter - size, yCenter - size, z, shouldAnimate, pos),
                  this.project3D(xCenter + size, yCenter - size, z, shouldAnimate, pos),
                ];
              }

              const avgZ = stickerCorners.reduce((sum, c) => sum + c.z, 0) / 4;
              stickers.push({ corners: stickerCorners, color, z: avgZ });
            });
          });

          // Add corner stickers
          this.cube.corners.forEach((corner, index) => {
            const pos = cornerPositions[index];
            const colors = corner.colors;
            const ori = corner.orientation;

            // Map each face to its color based on position
            const cornerMappings = [
              ['U', 'R', 'F'], // URF
              ['U', 'F', 'L'], // UFL
              ['U', 'L', 'B'], // ULB
              ['U', 'B', 'R'], // UBR
              ['D', 'F', 'R'], // DFR
              ['D', 'L', 'F'], // DLF
              ['D', 'B', 'L'], // DBL
              ['D', 'R', 'B'], // DRB
            ];

            const faceColorMap = Object.fromEntries(cornerMappings[index].map((face, i) => [face, colors[i]]));

            // Apply orientation
            // Define proper rotation order for each corner position
            const cornerRotationOrders = {
              0: ['U', 'R', 'F'], // URF
              1: ['U', 'F', 'L'], // UFL
              2: ['U', 'L', 'B'], // ULB
              3: ['U', 'B', 'R'], // UBR
              4: ['D', 'F', 'R'], // DFR
              5: ['D', 'L', 'F'], // DLF
              6: ['D', 'B', 'L'], // DBL
              7: ['D', 'R', 'B'], // DRB
            };

            const rotationOrder = cornerRotationOrders[index];
            const rotatedMap = Object.fromEntries(
              rotationOrder.map((face, i) => [face, faceColorMap[rotationOrder[(i + ori) % 3]]]),
            );

            // Draw stickers for each face this corner touches
            const facesToDraw = [];
            if (pos.y < 0) facesToDraw.push('U');
            else facesToDraw.push('D');
            if (pos.x > 0) facesToDraw.push('R');
            else facesToDraw.push('L');
            if (pos.z < 0) facesToDraw.push('F');
            else facesToDraw.push('B');

            facesToDraw.forEach(face => {
              const color = rotatedMap[face];

              let stickerCorners;
              const size = 0.333;
              const faceDistance = 1.01;
              const shouldAnimate =
                this.currentAnimation && this.isPieceAffectedByMove('corner', pos, this.currentAnimation.move);

              if (face === 'U' || face === 'D') {
                const y = (face === 'U' ? -1 : 1) * faceDistance;
                const xSign = pos.x > 0 ? 1 : -1;
                const zSign = pos.z > 0 ? 1 : -1;
                const xCenter = xSign * 0.667;
                const zCenter = zSign * 0.667;
                stickerCorners = [
                  this.project3D(xCenter + xSign * size, y, zCenter + zSign * size, shouldAnimate, pos),
                  this.project3D(xCenter - xSign * size, y, zCenter + zSign * size, shouldAnimate, pos),
                  this.project3D(xCenter - xSign * size, y, zCenter - zSign * size, shouldAnimate, pos),
                  this.project3D(xCenter + xSign * size, y, zCenter - zSign * size, shouldAnimate, pos),
                ];
              } else if (face === 'R' || face === 'L') {
                const x = (face === 'R' ? 1 : -1) * faceDistance;
                const ySign = pos.y > 0 ? 1 : -1;
                const zSign = pos.z > 0 ? 1 : -1;
                const yCenter = ySign * 0.667;
                const zCenter = zSign * 0.667;
                stickerCorners = [
                  this.project3D(x, yCenter + ySign * size, zCenter + zSign * size, shouldAnimate, pos),
                  this.project3D(x, yCenter - ySign * size, zCenter + zSign * size, shouldAnimate, pos),
                  this.project3D(x, yCenter - ySign * size, zCenter - zSign * size, shouldAnimate, pos),
                  this.project3D(x, yCenter + ySign * size, zCenter - zSign * size, shouldAnimate, pos),
                ];
              } else {
                const z = (face === 'F' ? -1 : 1) * faceDistance;
                const xSign = pos.x > 0 ? 1 : -1;
                const ySign = pos.y > 0 ? 1 : -1;
                const xCenter = xSign * 0.667;
                const yCenter = ySign * 0.667;
                stickerCorners = [
                  this.project3D(xCenter + xSign * size, yCenter + ySign * size, z, shouldAnimate, pos),
                  this.project3D(xCenter - xSign * size, yCenter + ySign * size, z, shouldAnimate, pos),
                  this.project3D(xCenter - xSign * size, yCenter - ySign * size, z, shouldAnimate, pos),
                  this.project3D(xCenter + xSign * size, yCenter - ySign * size, z, shouldAnimate, pos),
                ];
              }

              const avgZ = stickerCorners.reduce((sum, c) => sum + c.z, 0) / 4;
              stickers.push({ corners: stickerCorners, color, z: avgZ });
            });
          });

          // Sort stickers by z-depth (back to front)
          stickers.sort((a, b) => b.z - a.z);

          // Draw all stickers
          stickers.forEach(sticker => {
            this.drawSticker(sticker.corners, sticker.color);
          });

          // Draw solved indicator if cube is solved and no animations are running
          if (!this.animating && this.cube.isSolved()) {
            this.drawSolvedIndicator();
          }
        }

        drawSolvedIndicator() {
          const size = 30;
          const x = this.canvas.width - size - 10;
          const y = this.canvas.height - size - 10;

          // Draw green circle background
          this.ctx.beginPath();
          this.ctx.arc(x + size/2, y + size/2, size/2, 0, 2 * Math.PI);
          this.ctx.fillStyle = '#4CAF50';
          this.ctx.fill();
          this.ctx.strokeStyle = '#2E7D32';
          this.ctx.lineWidth = 2;
          this.ctx.stroke();

          // Draw white checkmark
          this.ctx.strokeStyle = 'white';
          this.ctx.lineWidth = 3;
          this.ctx.lineCap = 'round';
          this.ctx.lineJoin = 'round';
          
          this.ctx.beginPath();
          this.ctx.moveTo(x + size * 0.25, y + size * 0.5);
          this.ctx.lineTo(x + size * 0.45, y + size * 0.7);
          this.ctx.lineTo(x + size * 0.75, y + size * 0.3);
          this.ctx.stroke();
        }
      }

      // Initialize
      const cube = new RubiksCube();
      const renderer = new CubeRenderer(document.getElementById('canvas'), cube);

      // Scramble function
      // This tries to be clever for the rendering. If doing statistics, be dumb instead.
      async function scrambleCube() {
        const moves = ['U', "U'", 'D', "D'", 'R', "R'", 'L', "L'", 'F', "F'", 'B', "B'"];
        const scrambleLength = 30 + Math.floor(Math.random() * 11);

        // Helper function to get the base face (without prime)
        const getBaseFace = (move) => move.replace("'", "");

        // Helper function to get the inverse of a move
        const getInverse = (move) => move.includes("'") ? move.replace("'", "") : move + "'";

        // Helper function to check if two faces are opposite
        const areOppositeFaces = (face1, face2) => {
          const opposites = { 'U': 'D', 'D': 'U', 'R': 'L', 'L': 'R', 'F': 'B', 'B': 'F' };
          return opposites[face1] === face2;
        };

        const scramble = [];

        for (let i = 0; i < scrambleLength; i++) {
          let validMoves = [...moves];

          if (scramble.length > 0) {
            const lastMove = scramble[scramble.length - 1];
            const lastBaseFace = getBaseFace(lastMove);

            // Remove inverse of last move
            const lastInverse = getInverse(lastMove);
            validMoves = validMoves.filter(move => move !== lastInverse);

            // If last two moves were on same face, prevent third consecutive same face move
            if (scramble.length > 1) {
              const secondLastMove = scramble[scramble.length - 2];
              const secondLastBaseFace = getBaseFace(secondLastMove);

              if (lastBaseFace === secondLastBaseFace) {
                // Already have 2 consecutive moves on same face, don't allow a third
                validMoves = validMoves.filter(move => getBaseFace(move) !== lastBaseFace);
              }

              // Check for opposite face sandwich patterns
              // Case 1: U D U' - second-to-last and last are opposite faces
              if (areOppositeFaces(secondLastBaseFace, lastBaseFace)) {
                const secondLastInverse = getInverse(secondLastMove);
                validMoves = validMoves.filter(move => move !== secondLastInverse);
              }

              // Case 2: U D D U' - need to look back one more step
              if (scramble.length > 2) {
                const thirdLastMove = scramble[scramble.length - 3];
                const thirdLastBaseFace = getBaseFace(thirdLastMove);

                // If last two moves are same face and opposite to third-to-last, avoid third-to-last inverse
                if (lastBaseFace === secondLastBaseFace && areOppositeFaces(thirdLastBaseFace, lastBaseFace)) {
                  const thirdLastInverse = getInverse(thirdLastMove);
                  validMoves = validMoves.filter(move => move !== thirdLastInverse);
                }
              }
            }
          }

          // If we've filtered out all moves (shouldn't happen with good logic), fall back to rejection
          if (validMoves.length === 0) {
            validMoves = [...moves];
          }

          const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
          scramble.push(randomMove);
          await renderer.animateMove(randomMove);
        }
      }

      function resetCube() {
        cube.reset();
        renderer.render(); // Will show checkmark since cube is now solved
      }

      // Reset orientation function
      function resetOrientation() {
        renderer.orientation = [0.1, 0.8, 0.1, 0.6];
        renderer.render();
      }

      // Parse move sequence string into individual moves
      function parseMoveSequence(sequence) {
        // Remove all whitespace
        const cleanSequence = sequence.replace(/\s/g, '');
        const moves = [];
        const invalidChars = [];

        let i = 0;
        while (i < cleanSequence.length) {
          const char = cleanSequence[i];
          
          if (/[UDRLFBxyzMES]/.test(char)) {
            let move = char;
            
            // Check for prime or 2
            if (i + 1 < cleanSequence.length) {
              if (cleanSequence[i + 1] === "'") {
                move += "'";
                i++;
              } else if (cleanSequence[i + 1] === "2") {
                moves.push(move, move); // Add twice for double move
                i += 2;
                continue;
              }
            }
            
            moves.push(move);
          } else if (!invalidChars.includes(char)) {
            invalidChars.push(char);
          }
          i++;
        }

        return { moves, invalidChars };
      }

      // Show error modal
      function showErrorModal(message) {
        const dialog = document.getElementById('error-dialog');
        const messageElement = document.getElementById('error-message');
        messageElement.innerHTML = message;
        dialog.showModal();
      }

      // Hide error modal
      function hideErrorModal() {
        const dialog = document.getElementById('error-dialog');
        dialog.close();
      }

      // Execute a sequence of moves
      async function executeMoveSequence() {
        const input = document.getElementById('move-sequence');
        const sequence = input.value.trim();
        
        if (!sequence) return;

        const result = parseMoveSequence(sequence);
        
        // Check for invalid characters
        if (result.invalidChars.length > 0) {
          const invalidStr = result.invalidChars.map(c => `'${c}'`).join(', ');
          showErrorModal(`Unrecognized characters: ${invalidStr}<br><br>Valid characters are: U, D, R, L, F, B, x, y, z, ', 2`);
          return;
        }

        // Execute each move in sequence using visual moves
        for (const move of result.moves) {
          await renderer.animateVisualMove(move);
        }
      }

      let isRotating = false;
      let rotationDirection = 0; // 1 for clockwise, -1 for counterclockwise
      let rotationAnimationId = null;

      // Z-axis rotation functions
      function rotateZ(direction) {
        const rotationSpeed = 0.02; // Adjust speed as needed
        const zRotation = Math3D.quat_fromAxisAngle(Math3D.quat_create(), [0, 0, 1], direction * rotationSpeed);
        Math3D.quat_multiply(renderer.orientation, zRotation, renderer.orientation);
        Math3D.quat_normalize(renderer.orientation, renderer.orientation);
        renderer.render();
      }

      function startRotation(direction) {
        if (isRotating) return;
        isRotating = true;
        rotationDirection = direction;
        
        function animate() {
          if (isRotating) {
            rotateZ(rotationDirection);
            rotationAnimationId = requestAnimationFrame(animate);
          }
        }
        animate();
      }

      function stopRotation() {
        isRotating = false;
        if (rotationAnimationId) {
          cancelAnimationFrame(rotationAnimationId);
          rotationAnimationId = null;
        }
      }


      // Initial render
      renderer.render();

      // Setup rotation button event handlers
      const clockwiseBtn = document.getElementById('clockwise-btn');
      const counterclockwiseBtn = document.getElementById('counterclockwise-btn');

      // Clockwise button events
      clockwiseBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startRotation(-1);
      });

      clockwiseBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopRotation();
      });

      clockwiseBtn.addEventListener('mouseleave', (e) => {
        stopRotation();
      });

      // Counterclockwise button events  
      counterclockwiseBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startRotation(1);
      });

      counterclockwiseBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopRotation();
      });

      counterclockwiseBtn.addEventListener('mouseleave', (e) => {
        stopRotation();
      });

      // Stop rotation when mouse is released anywhere on the page
      document.addEventListener('mouseup', () => {
        stopRotation();
      });

      // Add Enter key support for move sequence input
      document.getElementById('move-sequence').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          executeMoveSequence();
        }
      });
    </script>
  </body>
</html>
